// @flow

import EventEmitter from 'events';

export type StateListener = (string => void) | EventEmitter;
export type Listener = ((...args: any[]) => void) | EventEmitter;


declare export class State<R> extends EventEmitter {
    static EVENT_CHANGE_STATE: 'changeState';
    static STATE_ERROR: 'error';

    static isState(mixed): boolean; //%checks (it instanceof State);
    static create<C: Function>(C, copyStatic?: boolean): C;
    static invoke<A, R>(fn: (...args: A) => R, args: ?A, thisArg?: mixed): R;

    isState: true;
    state: ?string;
    data: {[string]: mixed};
    keys: string[];
    stateData: mixed[];

    constructor(state: ?string): void;

    invoke<A, R>(fn: (...args: A) => R, args: ?A, thisArg?: mixed): R;
    destroy(recursive: ?boolean): this;
    is(state: string): boolean;
    setState(state: string, data: mixed): this;
    onState(state: string, listener: StateListener, thisArg?: mixed): this;
    onceState(state: string, listener: StateListener, thisArg?: mixed): this;
    onChangeState(listener: Listener, thisArg?: mixed): this;
    offChangeState(listener: Listener): this;
    setData(key: string, value: mixed): this;
    getData(key?: string): mixed;
    getStateData(key: string): mixed;
    toObject(keys?: string[]): Object;
    toJSON(): Object;
    setKeys(keys?: string[]): this;
}

declare export default class Response<R> extends State<R> {
    // Т.к. часто используется без отдельного импорта.
    static State: Class<State<R>>;
    static Queue: Class<Queue>;

    static STATE_PENDING: 'pending';
    static STATE_RESOLVED: 'resolve';
    static STATE_REJECTED: 'error';
    static EVENT_PROGRESS: 'progress';

    static isResponse(mixed): boolean; //%checks (it instanceof Response);
    static resolve(R: mixed): Response<R>;
    static reject(R: mixed): Response<R>;

    isResponse: true;

    constructor(parent?: Response<mixed> | Promise<mixed>): void;

    pending(): this;
    resolve(mixed): this;
    reject(mixed): this;
    progress(mixed): this;
    isPending(): boolean;
    isResolved(): boolean;
    isRejected(): boolean;

    then(onResolve?: Listener, onReject?: Listener, onProgress?: Listener, thisArg?: mixed): this;
    any(Listener, thisArg?: mixed): this;
    onPending(Listener, thisArg?: mixed): this;
    onResolve(Listener, thisArg?: mixed): this;
    onReject(Listener, thisArg?: mixed): this;
    onProgress(Listener, thisArg?: mixed): this;
    notify(Response<mixed>): this;
    listen(Response<mixed>): this;
    done(): this;
    fork(): Response<mixed>;
    map(Listener, thisArg?: mixed): this;
    getResult(string): mixed;
    getReason(): mixed;
}

declare export class Queue extends Response<mixed> {
    static EVENT_START: 'start';
    static EVENT_STOP: 'stop';
    static EVENT_NEXT_ITEM: 'nextItem';
    static EVENT_ITEM_REJECTED: 'itemRejected';

    static isQueue(mixed): boolean; //%checks (it instanceof Queue);

    isQueue: true;
    items: mixed[];
    item: mixed;
    isStarted: boolean;
    isStrict: boolean;
    context: any;

    constructor(items: ?Queue[] | Promise<mixed>[] | Function[] | mixed[], start?: boolean): void;

    start(args?: mixed[]): this;
    stop(): this;
    push(item: Response<mixed> | Function, name: string): this;
    strict(flag?: boolean): this;
    onStart(Listener, thisArg?: mixed): this;
    onStop(Listener, thisArg?: mixed): this;
    onNextItem(Listener, thisArg?: mixed): this;
    onItemRejected(Listener, thisArg?: mixed): this;
    bind(thisArg?: mixed): this;
}
